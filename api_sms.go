/*
Swagger Petstore - OpenAPI 3.0

This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [https://swagger.io](https://swagger.io). In the third iteration of the pet store, we've switched to the design first approach! You can now help us improve the API whether it's by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  _If you're looking for the Swagger 2.0/OAS 2.0 version of Petstore, then click [here](https://editor.swagger.io/?url=https://petstore.swagger.io/v2/swagger.yaml). Alternatively, you can load via the `Edit > Load Petstore OAS 2.0` menu option!_  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)

API version: 1.0.0
Contact: edson@michaque.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package buzi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)



// SmsApiService SmsApi service
type SmsApiService service

type CancelMessageRequest struct {
	ctx context.Context
	apiService *SmsApiService
	messageId int64
}

type CancelMessageResponse struct {
     Response *http.Response
     Value *Message
}

func (r CancelMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.apiService.doCancelMessage(r)
}

// CancelMessage Cancel a message
// 
//
// Returns a single pet
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param messageId ID of pet to return
//  @return CancelMessageRequest
// 
func (a *SmsApiService) CancelMessage(ctx context.Context, messageId int64) CancelMessageRequest {
	return CancelMessageRequest{
		apiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}


// Execute executes the request
//  @return Message
func (a *SmsApiService) doCancelMessage(r CancelMessageRequest) (*CancelMessageResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/messages/{messageId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(paramToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &CancelMessageResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &CancelMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &CancelMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &CancelMessageResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &CancelMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &CancelMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &CancelMessageResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type CreateMessageRequest struct {
	ctx context.Context
	apiService *SmsApiService
	createMessageInput *CreateMessageInput
}

type CreateMessageResponse struct {
     Response *http.Response
     Value *Message
}

func (r CreateMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.apiService.doCreateMessage(r)
}

// CreateMessage Create Message
// 
//
// Update an existing pet by Id
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return CreateMessageRequest
// 
func (a *SmsApiService) CreateMessage(ctx context.Context, createMessageInput CreateMessageInput) CreateMessageRequest {
	return CreateMessageRequest{
		apiService: a,
		ctx: ctx,
        createMessageInput: &createMessageInput,
	}
}


// Execute executes the request
//  @return Message
func (a *SmsApiService) doCreateMessage(r CreateMessageRequest) (*CreateMessageResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createMessageInput == nil {
		return &CreateMessageResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, reportError("createMessageInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createMessageInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &CreateMessageResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &CreateMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &CreateMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &CreateMessageResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &CreateMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &CreateMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &CreateMessageResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type CreatePricingRequest struct {
	ctx context.Context
	apiService *SmsApiService
	networkId int32
}

type CreatePricingResponse struct {
     Response *http.Response
     Value *Message
}

func (r CreatePricingRequest) Execute() (*Message, *http.Response, error) {
	return r.apiService.doCreatePricing(r)
}

// CreatePricing Create network price
// 
//
// Returns a single pet
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param networkId
//  @return CreatePricingRequest
// 
func (a *SmsApiService) CreatePricing(ctx context.Context, networkId int32) CreatePricingRequest {
	return CreatePricingRequest{
		apiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}


// Execute executes the request
//  @return Message
func (a *SmsApiService) doCreatePricing(r CreatePricingRequest) (*CreatePricingResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/networks/{networkId}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(paramToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &CreatePricingResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &CreatePricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &CreatePricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &CreatePricingResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &CreatePricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &CreatePricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &CreatePricingResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type DeleteMessageRequest struct {
	ctx context.Context
	apiService *SmsApiService
	messageId int64
}

type DeleteMessageResponse struct {
     Response *http.Response
     Value *Error
}

func (r DeleteMessageRequest) Execute() (*Error, *http.Response, error) {
	return r.apiService.doDeleteMessage(r)
}

// DeleteMessage Deletes a message
// 
//
// delete a message
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param messageId Pet id to delete
//  @return DeleteMessageRequest
// 
func (a *SmsApiService) DeleteMessage(ctx context.Context, messageId int64) DeleteMessageRequest {
	return DeleteMessageRequest{
		apiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}


// Execute executes the request
//  @return Error
func (a *SmsApiService) doDeleteMessage(r DeleteMessageRequest) (*DeleteMessageResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Error
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(paramToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.apiKey != nil {
		localVarHeaderParams["api_key"] = paramToString(*r.apiKey, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &DeleteMessageResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &DeleteMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &DeleteMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &DeleteMessageResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &DeleteMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &DeleteMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &DeleteMessageResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type GetMessageRequest struct {
	ctx context.Context
	apiService *SmsApiService
	messageId int64
}

type GetMessageResponse struct {
     Response *http.Response
     Value *Message
}

func (r GetMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.apiService.doGetMessage(r)
}

// GetMessage Get message
// 
//
// Returns a single pet
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param messageId ID of pet to return
//  @return GetMessageRequest
// 
func (a *SmsApiService) GetMessage(ctx context.Context, messageId int64) GetMessageRequest {
	return GetMessageRequest{
		apiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}


// Execute executes the request
//  @return Message
func (a *SmsApiService) doGetMessage(r GetMessageRequest) (*GetMessageResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(paramToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &GetMessageResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &GetMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &GetMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &GetMessageResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &GetMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &GetMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &GetMessageResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type GetNetworkRequest struct {
	ctx context.Context
	apiService *SmsApiService
	networkId int32
	options *GetNetworkOptions
}

type GetNetworkResponse struct {
     Response *http.Response
     Value *Network
}

func (r GetNetworkRequest) Execute() (*Network, *http.Response, error) {
	return r.apiService.doGetNetwork(r)
}

// GetNetwork Get network
// 
//
// Returns a single pet
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param networkId
//  @return GetNetworkRequest
// 
func (a *SmsApiService) GetNetwork(ctx context.Context, networkId int32, opts *GetNetworkOptions) GetNetworkRequest {
	return GetNetworkRequest{
		apiService: a,
		ctx: ctx,
		networkId: networkId,
        options: opt,
	}
}

type GetNetworkOptions struct {
     CountryCode int64
}

// Execute executes the request
//  @return Network
func (a *SmsApiService) doGetNetwork(r GetNetworkRequest) (*GetNetworkResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Network
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/networks/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(paramToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.countryCode != nil {
		localVarQueryParams.Add("country_code", paramToString(*r.countryCode, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &GetNetworkResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &GetNetworkResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &GetNetworkResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &GetNetworkResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &GetNetworkResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &GetNetworkResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &GetNetworkResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type GetPricingRequest struct {
	ctx context.Context
	apiService *SmsApiService
	networkId int32
}

type GetPricingResponse struct {
     Response *http.Response
     Value []Pricing
}

func (r GetPricingRequest) Execute() ([]Pricing, *http.Response, error) {
	return r.apiService.doGetPricing(r)
}

// GetPricing List network rates
// 
//
// Returns a single pet
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param networkId
//  @return GetPricingRequest
// 
func (a *SmsApiService) GetPricing(ctx context.Context, networkId int32) GetPricingRequest {
	return GetPricingRequest{
		apiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}


// Execute executes the request
//  @return []Pricing
func (a *SmsApiService) doGetPricing(r GetPricingRequest) (*GetPricingResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Pricing
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/networks/{networkId}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(paramToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &GetPricingResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &GetPricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &GetPricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &GetPricingResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &GetPricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &GetPricingResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &GetPricingResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type ListMessagesRequest struct {
	ctx context.Context
	apiService *SmsApiService
	options *ListMessagesOptions
}

type ListMessagesResponse struct {
     Response *http.Response
     Value []Message
}

func (r ListMessagesRequest) Execute() ([]Message, *http.Response, error) {
	return r.apiService.doListMessages(r)
}

// ListMessages List messages
// 
//
// Update an existing pet by Id
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ListMessagesRequest
// 
func (a *SmsApiService) ListMessages(ctx context.Context, opts *ListMessagesOptions) ListMessagesRequest {
	return ListMessagesRequest{
		apiService: a,
		ctx: ctx,
        options: opt,
	}
}

type ListMessagesOptions struct {
     Inbox string
     Status string
}

// Execute executes the request
//  @return []Message
func (a *SmsApiService) doListMessages(r ListMessagesRequest) (*ListMessagesResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Message
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inbox != nil {
		localVarQueryParams.Add("inbox", paramToString(*r.inbox, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", paramToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &ListMessagesResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &ListMessagesResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &ListMessagesResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &ListMessagesResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &ListMessagesResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &ListMessagesResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &ListMessagesResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type ListNetworksRequest struct {
	ctx context.Context
	apiService *SmsApiService
	options *ListNetworksOptions
}

type ListNetworksResponse struct {
     Response *http.Response
     Value []Network
}

func (r ListNetworksRequest) Execute() ([]Network, *http.Response, error) {
	return r.apiService.doListNetworks(r)
}

// ListNetworks List networks
// 
//
// Returns a single pet
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ListNetworksRequest
// 
func (a *SmsApiService) ListNetworks(ctx context.Context, opts *ListNetworksOptions) ListNetworksRequest {
	return ListNetworksRequest{
		apiService: a,
		ctx: ctx,
        options: opt,
	}
}

type ListNetworksOptions struct {
     CountryCode string
}

// Execute executes the request
//  @return []Network
func (a *SmsApiService) doListNetworks(r ListNetworksRequest) (*ListNetworksResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Network
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/networks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.countryCode != nil {
		localVarQueryParams.Add("country_code", paramToString(*r.countryCode, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &ListNetworksResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &ListNetworksResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &ListNetworksResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &ListNetworksResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &ListNetworksResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &ListNetworksResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &ListNetworksResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}

type SendMessageRequest struct {
	ctx context.Context
	apiService *SmsApiService
	messageId int64
}

type SendMessageResponse struct {
     Response *http.Response
     Value *Message
}

func (r SendMessageRequest) Execute() (*Message, *http.Response, error) {
	return r.apiService.doSendMessage(r)
}

// SendMessage Sends a message
// 
//
// Returns a single pet
// 
//
//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param messageId ID of pet to return
//  @return SendMessageRequest
// 
func (a *SmsApiService) SendMessage(ctx context.Context, messageId int64) SendMessageRequest {
	return SendMessageRequest{
		apiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}


// Execute executes the request
//  @return Message
func (a *SmsApiService) doSendMessage(r SendMessageRequest) (*SendMessageResponse, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Message
	)

	localBaseURL := a.client.cfg.BaseURL

	localVarPath := localBaseURL + "/v1/sms/messages/{messageId}/send"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(paramToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return &SendMessageResponse{
               Value: localVarReturnValue, 
               Response: nil,
        }, err
	}

	localVarHTTPResponse, err := a.client.performRequest(req)
	if err != nil || localVarHTTPResponse == nil {
    	return &SendMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
    	return &SendMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, err
    }

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return &SendMessageResponse{
                    Value: localVarReturnValue, 
                    Response: localVarHTTPResponse,
                }, newErr

			}
			newErr.model = v
        return &SendMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr

	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
        return &SendMessageResponse{
            Value: localVarReturnValue, 
            Response: localVarHTTPResponse,
        }, newErr
	}

    return &SendMessageResponse{
        Value: localVarReturnValue, 
        Response: localVarHTTPResponse,
    }, nil

}
